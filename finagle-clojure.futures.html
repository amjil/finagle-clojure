<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>finagle-clojure.futures documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Finagle-clojure 0.1.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>finagle-clojure</span></div></div></li><li class="depth-2 branch"><a href="finagle-clojure.duration.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>duration</span></div></a></li><li class="depth-2 branch"><a href="finagle-clojure.filter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>filter</span></div></a></li><li class="depth-2 branch"><a href="finagle-clojure.future-pool.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>future-pool</span></div></a></li><li class="depth-2 branch current"><a href="finagle-clojure.futures.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>futures</span></div></a></li><li class="depth-2 branch"><a href="finagle-clojure.scala.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>scala</span></div></a></li><li class="depth-2 branch"><a href="finagle-clojure.service.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>service</span></div></a></li><li class="depth-2 branch"><a href="finagle-clojure.thrift.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>thrift</span></div></a></li><li class="depth-2"><a href="finagle-clojure.timer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>timer</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="finagle-clojure.futures.html#var-await"><div class="inner"><span>await</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-collect"><div class="inner"><span>collect</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-ensure"><div class="inner"><span>ensure</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-ensure*"><div class="inner"><span>ensure*</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-exception"><div class="inner"><span>exception</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-flatmap"><div class="inner"><span>flatmap</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-flatmap*"><div class="inner"><span>flatmap*</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-for"><div class="inner"><span>for</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-handle"><div class="inner"><span>handle</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-handle*"><div class="inner"><span>handle*</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-map"><div class="inner"><span>map</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-map*"><div class="inner"><span>map*</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-match-class"><div class="inner"><span>match-class</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-on-failure"><div class="inner"><span>on-failure</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-on-failure*"><div class="inner"><span>on-failure*</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-on-success"><div class="inner"><span>on-success</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-on-success*"><div class="inner"><span>on-success*</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-rescue"><div class="inner"><span>rescue</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-rescue*"><div class="inner"><span>rescue*</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-transform"><div class="inner"><span>transform</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-value"><div class="inner"><span>value</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-within"><div class="inner"><span>within</span></div></a></li><li class="depth-1"><a href="finagle-clojure.futures.html#var-within*"><div class="inner"><span>within*</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">finagle-clojure.futures</h2><div class="doc"><div class="markdown"><p>Functions for working with <code>com.twitter.util.Future</code> objects. Futures are used to represent asynchronous operations in Finagle.</p><p>More info on the use of Futures (in Scala): * <a href="https://twitter.github.io/finagle/guide/Futures.html">https://twitter.github.io/finagle/guide/Futures.html</a> * <a href="https://twitter.github.io/scala_school/finagle.html">https://twitter.github.io/scala_school/finagle.html</a></p></div></div><div class="public anchor" id="var-await"><h3>await</h3><div class="usage"><code>(await f)</code></div><div class="doc"><div class="markdown"><p>Block until Future f is defined and return its value. You probably don&rsquo;t want to use this in production code. This should <em>never</em> be used in code that runs on a Finagle thread as it will block the reactor.</p><p>This should only be used to wait for an asynchronous operation in a synchronous environment.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
</ul><p><em>Returns</em>:  The value of <code>f</code> if it was successful.  Throws the contained Exception if <code>f</code> was unsuccessful.</p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L60">view source</a></div></div><div class="public anchor" id="var-collect"><h3>collect</h3><div class="usage"><code>(collect future-seq)</code></div><div class="doc"><div class="markdown"><p>Takes a seq of Futures, returns a Future of a seq of their values.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>future-seq</code>: a Clojure seq of Futures</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined when all Futures in <code>future-seq</code> have been defined.  The value of that Future will be a Clojure seq of the values of the Futures in <code>future-seq</code>.</p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L183">view source</a></div></div><div class="public anchor" id="var-ensure"><h3>ensure</h3><h4 class="type">macro</h4><div class="usage"><code>(ensure f &amp; body)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L310">view source</a></div></div><div class="public anchor" id="var-ensure*"><h3>ensure*</h3><div class="usage"><code>(ensure* f fn0)</code></div><div class="doc"><div class="markdown"><p>Apply scala.Function0 <code>fn0</code> when Future <code>f</code> is defined whether it is successful or not. This is primarily used for side-effects, the return value of <code>fn0</code> is ignored.</p><p>Note that ensure* accepts a scala.Function0, which is not the same as a Clojure IFn. Use <a href="finagle-clojure.scala.html#var-Function0">scala/Function0</a> to create a Function0, or use <a href="finagle-clojure.futures.html#var-ensure">ensure</a>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>fn0</code>: a scala.Function0 that will execute when <code>f</code> is defined.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined when <code>f</code> is defined and <code>fn0</code> has executed.</p><p>See <a href="finagle-clojure.scala.html#var-Function0">scala/Function0</a>, <a href="finagle-clojure.futures.html#var-ensure">ensure</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L290">view source</a></div></div><div class="public anchor" id="var-exception"><h3>exception</h3><div class="usage"><code>(exception t)</code></div><div class="doc"><div class="markdown"><p>Returns a defined Future with a Throw value of t. This can be used to create a Future that has failed immediately.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>t</code>: an instance of Throwable that the new Future should be defined with.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that is defined with the Throw value <code>t</code>.</p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L29">view source</a></div></div><div class="public anchor" id="var-flatmap"><h3>flatmap</h3><h4 class="type">macro</h4><div class="usage"><code>(flatmap f arg-binding &amp; body)</code></div><div class="doc"><div class="markdown"><p>Sugar for constructing a scala.Function1 &amp; applying <a href="finagle-clojure.futures.html#var-flatmap*">flatmap*</a> with it.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>arg-binding</code>: is a vector with 1 element, the name to bind the successful value of Future <code>f</code> to.</li>
  <li><code>body</code>: will execute when the (non-error) value of f is defined.  Its result should be a Future.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined when <code>f</code> is defined and the Future returned by executing <code>body</code> is defined.  If <code>f</code> results in an error then <code>body</code> won&rsquo;t run.</p><p>See <a href="finagle-clojure.futures.html#var-flatmap*">flatmap*</a> &amp; <a href="finagle-clojure.scala.html#var-Function">scala/Function</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L103">view source</a></div></div><div class="public anchor" id="var-flatmap*"><h3>flatmap*</h3><div class="usage"><code>(flatmap* f fn1)</code></div><div class="doc"><div class="markdown"><p>Apply scala.Function1 <code>fn1</code> with the value of Future <code>f</code> when <code>f</code> is defined with a value (not an exception). <code>fn1</code> should return a Future.</p><p>flatmap* is used to represent asynchronous transformations of the successful result of a Future. E.g. calling to a RPC service with the result of a previous call. <a href="finagle-clojure.futures.html#var-map*">map*</a> or <a href="finagle-clojure.futures.html#var-map">map</a> can be used to run synchronous transformations of the successful value of a Future.</p><p>Note that flatmap* accepts a scala.Function1, which is not the same as a Clojure IFn. Use <a href="finagle-clojure.scala.html#var-Function">scala/Function</a> to create a Function1, or use <a href="finagle-clojure.futures.html#var-flatmap">flatmap</a>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>fn1</code>: a scala.Function1 that will execute when the (non-error) value of <code>f</code> is defined. Its result should be a Future.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined when <code>f</code> is defined and the Future returned by calling <code>fn1</code> is defined.  If <code>f</code> results in an error then <code>fn1</code> won&rsquo;t run.</p><p>See <a href="finagle-clojure.scala.html#var-Function">scala/Function</a>, <a href="finagle-clojure.futures.html#var-flatmap">flatmap</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L77">view source</a></div></div><div class="public anchor" id="var-for"><h3>for</h3><h4 class="type">macro</h4><div class="usage"><code>(for bindings &amp; body)</code></div><div class="doc"><div class="markdown"><p>Like a scala for comprehension with Futures. <code>bindings</code> are pairs of [name future]. <code>body</code> is executed when all Futures are ready and should return a Future. Bindings can refer to Futures defined before them (which will be realized).</p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L169">view source</a></div></div><div class="public anchor" id="var-handle"><h3>handle</h3><h4 class="type">macro</h4><div class="usage"><code>(handle f arg-binding &amp; body)</code></div><div class="doc"><div class="markdown"><p>Sugar for constructing a scala.PartialFunction &amp; applying <a href="finagle-clojure.futures.html#var-handle*">handle*</a> with it. This is like <a href="finagle-clojure.futures.html#var-map">map</a> for when a Future results in an error.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>arg-binding</code>: is a vector with 1 element, the name to bind the value of Future <code>f</code>.</li>
  <li><code>body</code>: will execute when the (error) value of <code>f</code> is defined.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined when <code>f</code> is defined and the Future returned by calling <code>body</code> is defined.  If <code>f</code> is successful then <code>body</code> won&rsquo;t run.</p><p>See <a href="finagle-clojure.futures.html#var-handle*">handle*</a> &amp; <a href="finagle-clojure.scala.html#var-Function">scala/Function</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L271">view source</a></div></div><div class="public anchor" id="var-handle*"><h3>handle*</h3><div class="usage"><code>(handle* f pfn)</code></div><div class="doc"><div class="markdown"><p>Apply scala.PartialFunction pfn with the value of Future f when f is defined with a Throw (a Throwable). This is like <a href="finagle-clojure.futures.html#var-map*">map*</a> for when a Future results in an error.</p><p>handle* is used to represent synchronous transformations of the unsuccessful result of a Future. E.g. some CPU bound calculation like computing the hash of the result. No blocking operations should be run with handle*. <a href="finagle-clojure.futures.html#var-rescue*">rescue*</a> or <a href="finagle-clojure.futures.html#var-rescue">rescue</a> can be used to run asynchronous transformations of the unsuccessful value of a Future.</p><p>Note that handle* accepts a scala.PartialFunction, which is not the same as a Clojure IFn. Use <a href="finagle-clojure.scala.html#var-Function">scala/Function</a> to create a PartialFunction, or use <a href="finagle-clojure.futures.html#var-handle">handle</a>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>pfn</code>: a scala.PartialFunction that will execute when the value of <code>f</code> is defined with an unsuccessful value.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined when <code>f</code> is defined and the Future returned by calling <code>pfn</code> is defined.  If <code>f</code> is successful then <code>pfn</code> won&rsquo;t run.</p><p>See <a href="finagle-clojure.scala.html#var-Function">scala/Function</a>, <a href="finagle-clojure.futures.html#var-handle">handle</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L245">view source</a></div></div><div class="public anchor" id="var-map"><h3>map</h3><h4 class="type">macro</h4><div class="usage"><code>(map f arg-binding &amp; body)</code></div><div class="doc"><div class="markdown"><p>Sugar for constructing a scala.Function1 &amp; applying <a href="finagle-clojure.futures.html#var-map*">map*</a> with it.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>arg-binding</code>: is a vector with 1 element, the name to bind to the successful value of Future <code>f</code>.</li>
  <li><code>body</code>: will execute when the (non-error) value of <code>f</code> is defined.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined when <code>f</code> is defined and <code>body</code> has been applied to its value.  The value of the new Future will be the result of <code>body</code> if <code>f</code> is successful.  If <code>f</code> results in an error then <code>body</code> won&rsquo;t run.</p><p>See <a href="finagle-clojure.futures.html#var-map*">map*</a> &amp; <a href="finagle-clojure.scala.html#var-Function">scala/Function</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L148">view source</a></div></div><div class="public anchor" id="var-map*"><h3>map*</h3><div class="usage"><code>(map* f fn1)</code></div><div class="doc"><div class="markdown"><p>Apply scala.Function1 <code>fn1</code> with the value of Future <code>f</code> when <code>f</code> is defined with a value (not exception).</p><p>map* is used to represent synchronous transformations of the successful result of a Future. E.g. some CPU bound calculation like computing the hash of the result. No blocking operations should be run with map. <a href="finagle-clojure.futures.html#var-flatmap*">flatmap*</a> or <a href="finagle-clojure.futures.html#var-flatmap">flatmap</a> can be used to run asynchronous transformations of the successful value of a Future.</p><p>Note that map* accepts a scala.Function1, which is not the same as a Clojure IFn. Use <a href="finagle-clojure.scala.html#var-Function">scala/Function</a> to create a Function1, or use <a href="finagle-clojure.futures.html#var-map">map</a>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>fn1</code>: a scala.Function1 that will execute when the (non-error) value of <code>f</code> is defined.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined when <code>f</code> is defined and <code>fn1</code> has been applied to its value.  The value of the new Future will be the result of <code>fn1</code> if <code>f</code> is successful.  If <code>f</code> results in an error then <code>fn1</code> won&rsquo;t run.</p><p>See <a href="finagle-clojure.scala.html#var-Function">scala/Function</a>, <a href="finagle-clojure.futures.html#var-map">map</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L122">view source</a></div></div><div class="public anchor" id="var-match-class"><h3>match-class</h3><h4 class="type">macro</h4><div class="usage"><code>(match-class value &amp; body)</code></div><div class="doc"><div class="markdown"><p>Sugar for conditional execution based on the class of the first argument <code>value</code>. Useful for handling different types of Exceptions in error callbacks.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>value</code>: the class of this argument will be used to dispatch with <code>body</code>.</li>
  <li><code>body</code>: like the body of a cond expression: expected-class expr</li>
</ul><p>e.g.</p>
<pre><code>(match-class (IllegalArgumentException.)
  IllegalArgumentException (value :illegal-argument)
  Exception (value :an-error))
</code></pre><p><em>Returns</em>:</p><p>The result of the expression that matches the class of <code>value</code>.</p><p>See <a href="finagle-clojure.futures.html#var-handle">handle</a>, <a href="finagle-clojure.futures.html#var-rescue">rescue</a>, <a href="finagle-clojure.futures.html#var-transform">transform</a>.</p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L407">view source</a></div></div><div class="public anchor" id="var-on-failure"><h3>on-failure</h3><h4 class="type">macro</h4><div class="usage"><code>(on-failure f arg-binding &amp; body)</code></div><div class="doc"><div class="markdown"><p>Sugar for constructing a <code>scala.Function1</code> &amp; applying <a href="finagle-clojure.futures.html#var-on-failure*">on-failure*</a> with it.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a <code>Future</code>.</li>
  <li><code>arg-binding</code>: is a vector with 1 element, the name to bind the value of Future <code>f</code>.</li>
  <li><code>body</code>: will execute when the error value of <code>f</code> is defined.  <code>body</code> will be transformed to automatically return a scala.Unit value for compatibility.</li>
</ul><p><em>Returns</em>:</p><p>A <code>Future</code> that will run <code>body</code> when it is defined with an error value.</p><p>See <a href="finagle-clojure.futures.html#var-on-failure*">on-failure*</a> &amp; <a href="finagle-clojure.scala.html#var-Function">scala/Function</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L495">view source</a></div></div><div class="public anchor" id="var-on-failure*"><h3>on-failure*</h3><div class="usage"><code>(on-failure* f fn1)</code></div><div class="doc"><div class="markdown"><p>Apply scala.Function1 <code>fn1</code> with the value of Future <code>f</code> when <code>f</code> is defined with an exception. The return value of <code>fn1</code> is ignored. While this is used for side effects it still should not block the thread on which it runs.</p><p>Note that on-failure* accepts a scala.Function1, which is not the same as a Clojure IFn. Use <a href="finagle-clojure.scala.html#var-Function">scala/Function</a> to create a Function1, or use <a href="finagle-clojure.futures.html#var-on-failure">on-failure</a>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>fn1</code>: a scala.Function1 that will execute when the error value of <code>f</code> is defined. <code>fn1</code> should return scala.Unit.</li>
</ul><p><em>Returns</em>:</p><p>A <code>Future</code> that will run <code>fn1</code> when it is defined with an error value.</p><p>See <a href="finagle-clojure.scala.html#var-Function">scala/Function</a>, <a href="finagle-clojure.futures.html#var-on-failure">on-failure</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L473">view source</a></div></div><div class="public anchor" id="var-on-success"><h3>on-success</h3><h4 class="type">macro</h4><div class="usage"><code>(on-success f arg-binding &amp; body)</code></div><div class="doc"><div class="markdown"><p>Sugar for constructing a scala.Function1 &amp; applying <a href="finagle-clojure.futures.html#var-on-success*">on-success*</a> with it.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future.</li>
  <li><code>arg-binding</code>: is a vector with 1 element, the name to bind the successful value of Future <code>f</code>.</li>
  <li><code>body</code>: will execute when the (non-error) value of <code>f</code> is defined.  <code>body</code> will be transformed to automatically return a scala.Unit value for compatibility.</li>
</ul><p><em>Returns</em>:</p><p>A Future that will run <code>body</code> when it is defined with a successful value.</p><p>See <a href="finagle-clojure.futures.html#var-on-success*">on-success*</a> &amp; <a href="finagle-clojure.scala.html#var-Function">scala/Function</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L455">view source</a></div></div><div class="public anchor" id="var-on-success*"><h3>on-success*</h3><div class="usage"><code>(on-success* f fn1)</code></div><div class="doc"><div class="markdown"><p>Apply scala.Function1 <code>fn1</code> with the value of Future <code>f</code> when <code>f</code> is defined with a value (not exception). The return value of <code>fn1</code> is ignored. While this is used for side effects it still should not block the thread on which it runs.</p><p>Note that on-success* accepts a scala.Function1, which is not the same as a Clojure IFn. Use <a href="finagle-clojure.scala.html#var-Function">scala/Function</a> to create a Function1, or use <a href="finagle-clojure.futures.html#var-on-success">on-success</a>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>fn1</code>: a scala.Function1 that will execute when the (non-error) value of <code>f</code> is defined. <code>fn1</code> should return <code>scala.Unit</code>.</li>
</ul><p><em>Returns</em>:</p><p>A Future that will run <code>fn1</code> when it is defined with a successful value.</p><p>See <a href="finagle-clojure.scala.html#var-Function">scala/Function</a>, <a href="finagle-clojure.futures.html#var-on-success">on-success</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L433">view source</a></div></div><div class="public anchor" id="var-rescue"><h3>rescue</h3><h4 class="type">macro</h4><div class="usage"><code>(rescue f arg-binding &amp; body)</code></div><div class="doc"><div class="markdown"><p>Sugar for constructing a scala.PartialFunction &amp; applying <a href="finagle-clojure.futures.html#var-rescue*">rescue*</a> with it. This is like <a href="finagle-clojure.futures.html#var-flatmap">flatmap</a> for when a Future results in an error.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>arg-binding</code>: is a vector with 1 element, the name to bind the unsuccessful value of Future <code>f</code>.</li>
  <li><code>body</code>: will execute when the (error) value of <code>f</code> is defined. The return value should be a Future.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined when <code>f</code> is defined and the Future returned by calling <code>body</code> is defined.  If <code>f</code> is successful then <code>body</code> won&rsquo;t run.</p><p>See <a href="finagle-clojure.futures.html#var-rescue*">rescue*</a> &amp; <a href="finagle-clojure.scala.html#var-Function">scala/Function</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L225">view source</a></div></div><div class="public anchor" id="var-rescue*"><h3>rescue*</h3><div class="usage"><code>(rescue* f pfn)</code></div><div class="doc"><div class="markdown"><p>Apply scala.PartialFunction <code>pfn</code> with the value of Future <code>f</code> when <code>f</code> is defined with an unsuccessful value (a Throwable). This is like <a href="finagle-clojure.futures.html#var-flatmap*">flatmap*</a> for when a Future results in an error.</p><p>rescue* is used to represent asynchronous transformations of the unsuccessful result of a Future. <a href="finagle-clojure.futures.html#var-handle*">handle*</a> or <a href="finagle-clojure.futures.html#var-handle">handle</a> can be used to run synchronous transformations of the unsuccessful value of a Future.</p><p>Note that rescue* accepts a scala.PartialFunction, which is not the same as a Clojure IFn. Use <a href="finagle-clojure.scala.html#var-Function">scala/Function</a> to create a PartialFunction, or use <a href="finagle-clojure.futures.html#var-rescue">rescue</a>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>pfn</code>: a scala.PartialFunction that will execute when the value of <code>f</code> is defined with an unsuccessful value. The return value should be a Future.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined when <code>f</code> is defined and the Future returned by calling <code>pfn</code> is defined.  If <code>f</code> is successful then <code>pfn</code> won&rsquo;t run.</p><p>See <a href="finagle-clojure.scala.html#var-Function">scala/Function</a>, <a href="finagle-clojure.futures.html#var-rescue">rescue</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L200">view source</a></div></div><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"><code>(select f1 f2)</code></div><div class="doc"><div class="markdown"><p><em>Arguments</em>:</p>
<ul>
  <li><code>f1</code>: a <code>Future</code></li>
  <li><code>f2</code>: a <code>Future</code></li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined with the value of the Future that returns first (between <code>f1</code> &amp; <code>f2</code>).</p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L328">view source</a></div></div><div class="public anchor" id="var-transform"><h3>transform</h3><div class="usage"><code>(transform f success-fn)</code><code>(transform f success-fn failure-fn)</code></div><div class="doc"><div class="markdown"><p>Returns a new <code>Future</code> that will transform its value when defined using the supplied fns. This is sugar around chaining flatmap &amp; rescue, so the supplied functions should return a <code>Future</code>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a Future</li>
  <li><code>success-fn</code>: a Clojure IFn that will be called with the successful value of <code>f</code> when it&rsquo;s defined.  <code>success-fn</code> should return a Future.</li>
  <li><code>failure-fn</code>: a Clojure IFn that will be called with the exception that defines <code>f</code>.  <code>failure-fn</code> should return a Future. Exceptions will not be <a href="finagle-clojure.futures.html#var-rescue">rescue</a> if this isn&rsquo;t passed.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined once <code>f</code> has been defined and the Future returned by the transformation fns has been defined.</p><p>See <a href="finagle-clojure.futures.html#var-flatmap">flatmap</a> &amp; <a href="finagle-clojure.futures.html#var-rescue">rescue</a>.</p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L381">view source</a></div></div><div class="public anchor" id="var-value"><h3>value</h3><div class="usage"><code>(value v)</code></div><div class="doc"><div class="markdown"><p>Returns a defined Future with the constant Return value <code>v</code>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>v</code>: the value that the new Future should be defined with.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that is defined with the value <code>v</code>.</p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L16">view source</a></div></div><div class="public anchor" id="var-within"><h3>within</h3><div class="usage"><code>(within f timeout-value timeout-unit)</code><code>(within f timeout-value timeout-unit timer)</code></div><div class="doc"><div class="markdown"><p>Returns a new Future that will error if not complete within <code>timeout-value</code> <code>timeout-unit</code>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a <code>Future</code></li>
  <li><code>timeout-value</code></li>
  <li><code>timeout-unit</code>: the unit for the timeout Duration (see <a href="finagle-clojure.duration.html#var--.3EDuration">finagle-clojure.duration/->Duration</a>).</li>
  <li><code>timer</code> (optional): a com.twitter.util.Timer that schedules the check to see if <code>f</code> isn&rsquo;t defined after <code>timeout-value</code>. When not specified a default Timer is used.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined with a TimeoutException if it isn&rsquo;t otherwise defined within <code>timeout-value</code> <code>timeout-unit</code>s.</p><p>See <a href="finagle-clojure.futures.html#var-within*">within*</a> &amp; <a href="finagle-clojure.duration.html#var--.3EDuration">finagle-clojure.duration/->Duration</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L360">view source</a></div></div><div class="public anchor" id="var-within*"><h3>within*</h3><div class="usage"><code>(within* f timeout-duration)</code><code>(within* f timeout-duration timer)</code></div><div class="doc"><div class="markdown"><p>Returns a new Future that will error if not complete within <code>timeout-duration</code>.</p><p><em>Arguments</em>:</p>
<ul>
  <li><code>f</code>: a <code>Future</code></li>
  <li><code>timeout-duration</code>: a com.twitter.util.Duration indicating how long to wait before erroring.</li>
  <li><code>timer</code> (optional): a com.twitter.util.Timer that schedules the check to see if <code>f</code> isn&rsquo;t defined after <code>timeout-duration</code>. When not specified a default Timer is used.</li>
</ul><p><em>Returns</em>:</p><p>A new Future that will be defined with a TimeoutException if it isn&rsquo;t otherwise defined within <code>timeout-duration</code>.</p><p>See <a href="finagle-clojure.duration.html#var--.3EDuration">finagle-clojure.duration/->Duration</a>, <a href="finagle-clojure.futures.html#var-within">within</a></p></div></div><div class="src-link"><a href="https://github.com/finagle/finagle-clojure/blob/v0.1.0/core/src/finagle_clojure/futures.clj#L340">view source</a></div></div></div></body></html>